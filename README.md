# printserver
This program considers a single globally shared printer queue that all processes and threads can read from or write into. The print queue has a finite size of 20 print jobs. 
Producer-Consumer problem: user processes versus consumer threads. 
The user processes are producers and add print requests into the queue. Each print request is characterized by itâ€™s size (in bytes). Each user can submit upto 20 print jobs.  
The different printers are consumers and run on different threads. Each printer can process a print job and removes it from the global print queue. 
The main process reads the command line to determine the parameters, start the producer processes and consumer threads, and acts like an interactive command console. It also initializes the print queue but cannot modify it after initialization. 
The command line parameters include: (i) number of producer (user) processes, and (ii)  number of printer (consumer) threads.
Each of the printer threads processes one print request at a time depending on their availability for as long as the queue is not empty.

For terminating conditions, the implementation was a bit different for the two different implementations, LIFO, and FIFO. Essentially the condition that was checked was when the queue was empty. For LIFO, I just checked to see if buffer index had reached 0, after all the processes have been terminated, and joined the threads, cleaned up all memory, and destroyed all the semaphores. For FIFO, instead of checking if buffer index is 0, I checked the read and write pointers and when they were equal after all the processes had terminated, that meant all the jobs were added and consumed, so it should be terminated. 
In terms of sharing between processes and threads, everything was done on shared memory. All the semaphores, the global buffer, and the buffer index were on shared memory. In LIFO, to avoid deadlocks, a binary semaphore was used instead of a mutex to lock and unlock each process while adding the jobs to the queue, and the threads dequeuing requests to make sure all the processes and threads are synchronized. For FIFO I used separate binary semaphores to control the read and write pointers, so I had one semaphore to control producers and a second one to control consumers. For the bonus, a binary semaphore was added in the struct for each print request and access to the read and write pointer was controlled using these binary semaphores, instead of the single binary semaphore for read and write pointer used in FIFO.
To gracefully terminate interrupt from control-c, the signal handler sleeps for ten seconds for the producers to complete before terminating all the consumer threads. It cleans up the shared memory to make sure there are no leaks or errors and destroys the semaphores. The same process for graceful termination was used in both LIFO, FIFO, and bonus. 
In LIFO, I used a buffer index to traverse through the queue and in FIFO, a write pointer was used to go through the buffer and let processes add jobs to the queue while a read pointer was used for the consumer threads to begin consuming from the beginning till all the jobs were consumed. Both the read and write pointers loop through the buffer size and start back at the beginning of the queue.

